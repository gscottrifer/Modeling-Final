library(parallel)
library(doParallel)
library(igraph)
library(rlist) 
library(dplyr)
library(ggplot2)
library(ggridges)
library(tidyr)
library(ggraph)
library(stringr)

?count

#GLOBAL PARAMETERS

#this parameter controls the number of initial nodes, as well as the number of nodes each new node
#is connected to
m <- 2

#parameter to control number of time steps model runs for
cycles <- 100
#controls how much each node influences its neighbors
connection_weight <- 0.05

#global threshold
global.threshold<-50:51

global.steepness<-9:10


#copying over the draw net function for visualizing networks and modifying it slightly
draw.net <- function(net) {
  
  net.ig <- igraph::as.directed(igraph::graph_from_adj_list(net))
  
  deg <- degree(net.ig, mode="out")
  V(net.ig)$size <- deg*5
  
  graphics::plot(net.ig, edge.arrow.size=.5, edge.curved=.2, arrow.mode="forward")
  
}

draw.net.large.network<- function(net) {
  
  net.ig <- igraph::as.directed(igraph::graph_from_adj_list(net))
  
  deg <- degree(net.ig, mode="out")
  V(net.ig)$size <- deg*1
  l <- layout.kamada.kawai(net.ig)
  l <- layout.norm(l, ymin=-1.3, ymax=1.3, xmin=-1.3, xmax=1.3)
  graphics::plot(net.ig, edge.arrow.size=.2, edge.curved=.2, arrow.mode="forward", rescale=F,layout=l*1.0)
  
}


#writing the function to take the list generated by test and use it to populate the empty matrix
#all connections except the influencer node are bidirectional
initialize_matrix <- function(empty_matrix,network, population) {
for(i in 1:population){
  connection_vector <- network[[i]]
  for (j in 1: population) {
    ifelse(j %in% connection_vector, empty_matrix[j,i]<-1, empty_matrix[j,i]<-0)
  }
}
  return(empty_matrix)
}


#function to randomly select "seed" nodes, takes empty activation values vector and returns
#randomly selected nodes
select_influencers <- function(activation_values, seed) {
  influencer_node <- sample(1:population, seed, replace=FALSE)
  activation_values[influencer_node] <- 1
  return(activation_values)
  #potentially add code to remove ingoing connections from influencer nodes
}


#write a function that instead of randomly selecting an influencer adds an influencer to the network
#takes in a network and returns same network with an added influencer node


add_influencer<- function(network, influencer.degree, population) {
  network<-list.append(network,sample(1:population, size=influencer.degree))
  return(network)
}




activate_influencer<- function(activation_values, population) {
  activation_values[1,population+1]<- 1
  return(activation_values)
}





#add another tool that models the decay of the process, decay current activation values before adding input
update.rule<- function(activation_values, connection.matrix, population) {
for(cycle in 2:cycles) {
  #this vector contains for each node what its total input is
  input.to.each.node <- rep(0,(population+1))
  #for each node determine its inputs and the activation of those nodes, then 
  #multiply by connection weight and sum using combination rule
  for(node in 1:(population+1)) {
    #this vector contains for each node all the individual inputs
    input.vector <- rep(0, population+1)
    for(input in 1:population+1){
      ##add ifelse for first cycle
      input.vector[input]<-if_else(connection.matrix[node,input]==1,activation_values[cycle-1,input]*connection_weight,0)
    }
    #creating vector for threshold
    thresholds<- (sample(global.threshold, population+1, replace=T)*0.01)
    steepness.values<- sample(global.steepness, population+1, replace=T)
    input.to.each.node[node]<- combination.rule(unlist(input.vector), thresholds,steepness.values, node)
  }
  #add another dimension here to track activation over each cycle
  activation_values[cycle,]<-activation_values[cycle-1,]+input.to.each.node
  #activity needs to be bounded between 0 and 1
  for(i in 1:(population+1)) {
    activation_values[cycle,i]<- ifelse(activation_values[cycle,i]>=1, 1, activation_values[cycle,i])
  }
}
  return(activation_values)
}


#write the function for the combination of different inputs
combination.rule <- function(input.vector, threshold.vector, steepness.values,node) {
  if(length(input.vector)<=1) {
    combined.input<- (1/(1+exp(-steepness.values[node]*(input.vector-threshold.vector[node])))-(1/(1+exp(threshold.vector[node]*steepness.values[node]))))*(1+exp(-threshold.vector[node]*steepness.values[node]))
  } else{
  combined.input<- (1/(1+exp(-steepness.values[node]*(sum(input.vector)-threshold.vector[node])))-(1/(1+exp(threshold.vector[node]*steepness.values[node]))))*(1+exp(-threshold.vector[node]*steepness.values[node]))
  }
  return(if_else(combined.input<0, 0, combined.input) )
}


