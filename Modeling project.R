library(parallel)
library(doParallel)
library(igraph)
library(rlist) 
library(dplyr)


#copying over the draw net function for visualizing networks
draw.net <- function(net) {
  
  net.ig <- igraph::as.directed(igraph::graph_from_adj_list(net))
  
  graphics::plot(net.ig)
  
}




#population parameter controls the number of nodes
#this parameter controls the number of initial nodes, as well as the number of nodes each new node
#is connected to
m <- 2

#writing the function to take the list generated by test and use it to populate the empty matrix
#all connections except the influencer node are bidirectional
initialize_matrix <- function(empty_matrix,network, population) {
for(i in 1:population){
  connection_vector <- network[[i]]
  for (j in 1: population) {
    ifelse(j %in% connection_vector, empty_matrix[j,i]<-1, empty_matrix[j,i]<-0)
  }
}
  return(empty_matrix)
}


#function to randomly select "seed" nodes, takes empty activation values vector and returns
#randomly selected nodes
select_influencers <- function(activation_values, seed) {
  influencer_node <- sample(1:population, seed, replace=FALSE)
  activation_values[influencer_node] <- 1
  return(activation_values)
  #potentially add code to remove ingoing connections from influencer nodes
}


#write a function that instead of randomly selecting an influencer adds an influencer to the network
#takes in a network and returns same network with an added influencer node


add_influencer<- function(network, influencer.degree, population) {
  network<-list.append(network,sample(1:population, size=influencer.degree))
  return(network)
}




activate_influencer<- function(activation_values, population) {
  activation_values[population+1]<- 1
  return(activation_values)
}

?list.append
?sample


#write function for update steps
#parameter to control number of time steps model runs for
cycles <- 100
#controls how much each node influences its neighbors
connection_weight <- 0.05


#add decay to the update rule

?vector()

#add another tool that models the decay of the process, decay current activation values before adding input
update.rule<- function(activation_values, connection.matrix, population) {
for(cycle in 1:cycles) {
  input.to.each.node <- rep(0,(population+1))
  #for each node determine its inputs and the activation of those nodes, then 
  #multiply by connection weight and sum using combination rule
  for(node in 1:(population+1)) {
    input.vector <- rep(0, population+1)
    for(input in 1:population+1){
      input.vector[node]<-if_else(connection.matrix[node,input]==1,activation_values[input]*connection_weight,0)
    }
    input.vector<- sapply(input.vector, function(input.vector) {input.vector[input.vector!=0]})
    input.to.each.node[node]<- combination.rule(unlist(input.vector))
  }
  #add another dimension here to track activation over each cycle
  activation_values<-activation_values+input.to.each.node
}
  return(activation_values)
}

threshold <- 0.5
steepness<- 10

#write the function for the combination of different inputs
combination.rule <- function(input.vector) {
  #if only one input use identity rule
  #else call alogistic combination
  combined.input<- ((1/(1+exp(-threshold*sum(input.vector)-threshold)))-1/(1+exp(-threshold*steepness))*(1+exp(-threshold*steepness)))
  return(combined.input)
}



?exp()
