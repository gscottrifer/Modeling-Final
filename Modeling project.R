library(parallel)
library(doParallel)
library(igraph)
library(rlist) 
library(dplyr)
library(ggplot2)
library(ggridges)
library(tidyr)
library(ggraph)

#copying over the draw net function for visualizing networks
draw.net <- function(net) {
  
  net.ig <- igraph::as.directed(igraph::graph_from_adj_list(net))
  
  deg <- degree(net.ig, mode="out")
  V(net.ig)$size <- deg*5
  
  graphics::plot(net.ig)
  
}




#population parameter controls the number of nodes
#this parameter controls the number of initial nodes, as well as the number of nodes each new node
#is connected to
m <- 2

#writing the function to take the list generated by test and use it to populate the empty matrix
#all connections except the influencer node are bidirectional
initialize_matrix <- function(empty_matrix,network, population) {
for(i in 1:population){
  connection_vector <- network[[i]]
  for (j in 1: population) {
    ifelse(j %in% connection_vector, empty_matrix[j,i]<-1, empty_matrix[j,i]<-0)
  }
}
  return(empty_matrix)
}


#function to randomly select "seed" nodes, takes empty activation values vector and returns
#randomly selected nodes
select_influencers <- function(activation_values, seed) {
  influencer_node <- sample(1:population, seed, replace=FALSE)
  activation_values[influencer_node] <- 1
  return(activation_values)
  #potentially add code to remove ingoing connections from influencer nodes
}


#write a function that instead of randomly selecting an influencer adds an influencer to the network
#takes in a network and returns same network with an added influencer node


add_influencer<- function(network, influencer.degree, population) {
  network<-list.append(network,sample(1:population, size=influencer.degree))
  return(network)
}




activate_influencer<- function(activation_values, population) {
  activation_values[1,population+1]<- 1
  return(activation_values)
}

?list.append
?sample


#write function for update steps
#parameter to control number of time steps model runs for
cycles <- 100
#controls how much each node influences its neighbors
connection_weight <- 0.05


#add decay to the update rule

?vector()

#add another tool that models the decay of the process, decay current activation values before adding input
update.rule<- function(activation_values, connection.matrix, population) {
for(cycle in 2:cycles) {
  #this vector contains for each node what its total input is
  input.to.each.node <- rep(0,(population+1))
  #for each node determine its inputs and the activation of those nodes, then 
  #multiply by connection weight and sum using combination rule
  for(node in 1:(population+1)) {
    #this vector contains for each node all the individual inputs
    input.vector <- rep(0, population+1)
    for(input in 1:population+1){
      ##add ifelse for first cycle
      input.vector[input]<-if_else(connection.matrix[node,input]==1,activation_values[cycle-1,input]*connection_weight,0)
    }
    input.to.each.node[node]<- combination.rule(unlist(input.vector))
  }
  #add another dimension here to track activation over each cycle
  activation_values[cycle,]<-activation_values[cycle-1,]+input.to.each.node
  sapply(activation_values[cycle,], combination.rule)
}
  return(activation_values)
}

threshold <- 0.5
steepness<- 10

#write the function for the combination of different inputs
combination.rule <- function(input.vector) {
  #if only one input use identity rule
  #else call alogistic combination
  combined.input<- (1/(1+exp(-steepness*(sum(input.vector)-threshold)))-(1/(1+exp(threshold*steepness))))*(1+exp(-threshold*steepness))
  return(if_else(combined.input<0, 0, combined.input) )
}



?exp()

