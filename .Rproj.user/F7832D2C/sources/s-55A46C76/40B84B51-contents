library(parallel)
library(doParallel)
library(igraph)
#population parameter controls the number of nodes
population <- 10
#this parameter controls the number of initial nodes, as well as the number of nodes each new node
#is connected to
m <- 2

#test.network <- net.barabasi.albert(population,m,detectCores(),TRUE)

#draw.net(network)

#metric.cluster.global(test)

#histo.dist(test)


#neighbors(network, 2)


#writing code to transform generated list into a matrix

#create an empty matrix

#initial_matrix <- matrix(,population,population)

#writing the function to take the list generated by test and use it to populate the empty matrix
initialize_matrix <- function(empty_matrix,network) {
for(i in 1:population){
  connection_vector <- neighbors(network,i)
  for (j in 1: population) {
    ifelse(j %in% connection_vector, empty_matrix[i,j]<-1, empty_matrix[i,j]<-0)
  }
}
  return(empty_matrix)
}

connection_matrix <- initialize_matrix(initial_matrix)

#writing the function that will update the activation values vector at each time step
#initialize an empty vector of activation values with length of population

activation_values <- rep(0,population)

#set a random subset of the population to be activated initially, 
#controls size of seed

seed <- 10

#function to randomly select "seed" nodes, takes empty activation values vector and returns
#randomly selected nodes
select_influencers <- function(activation_values) {
  influencer_node <- sample(1:population, seed, replace=FALSE)
  activation_values[influencer_node] <- 1
  return(activation_values)
  #potentially add code to remove ingoing connections from influencer nodes
}

activation_values<-select_influencers(activation_values)

#write function for update steps
#parameter to control number of time steps model runs for
cycles <- 100
#controls how much each node influences its neighbors
connection_weight <- 0.05


update.rule<- function(activation_values, network) {
for(cycle in 1:cycles) {
  input.to.each.node <- rep(0,population)
  #for each node determine its inputs and the activation of those nodes, then sum inputs and
  #multiply by connection weight
  for(node in 1: population) {
    input_nodes<- neighbors(network, node)
    input.vector<- rep(0, length(input_nodes))
    for(input in 1:length(input.vector)){
      input.activation<-activation_values[input_nodes[input]]
      input.vector[input]<-input.activation
    }
    input.to.each.node[node]<- sum(input.vector)*connection_weight
  }
  activation_values<-activation_values+input.to.each.node
}
  return(activation_values)
}




